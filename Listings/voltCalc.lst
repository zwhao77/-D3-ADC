C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 12:18:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE VOLTCALC
OBJECT MODULE PLACED IN .\Objects\voltCalc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE voltCalc.c OPTIMIZE(8,SPEED) PRINT(.\Listings\voltCalc.lst) TABS(2) OBJE
                    -CT(.\Objects\voltCalc.obj)

line level    source

   1          #define uchar unsigned char
   2          #include <AT89X52.h>
   3          #include <absacc.h>
   4          #include <math.h>
   5          #include "ADC0808.h"
   6          #include "delay.h"
   7          #define DV 20
   8          #define LV 50
   9          #define LASTA 0.3
  10          #define MAXDEB 5
  11          extern uchar volt;
  12          extern uchar port;
  13          uchar tmpPort = 200;
  14          uchar slidV[5];
  15          uchar debnum = 0;
  16          // 平均值滤波
  17          uchar avgFilt()
  18          {
  19   1          uchar V[5];
  20   1          int num = 0;
  21   1          int i = 0;
  22   1          for (i = 0; i < 5; i++)
  23   1          {
  24   2              V[i] = getVolt();
  25   2          }
  26   1          for (i = 0; i < 5; i++)
  27   1          {
  28   2              num += V[i];
  29   2          }
  30   1          return ((uchar)(num / 5));
  31   1      }
  32          
  33          // 滑动平均滤波
  34          uchar slideavgFilt()
  35          {
  36   1          uchar i = 0;
  37   1          uchar tmp;
  38   1          int num;
  39   1          if (tmpPort != port)
  40   1          {
  41   2              delay_nms(20);
  42   2              tmp = getVolt();
  43   2              for (i = 0; i < 5; i++)
  44   2              {
  45   3                  slidV[i] = tmp;
  46   3              }
  47   2              return tmp;
  48   2          }
  49   1          else
  50   1          {
  51   2              for (i = 4; i > 0; i--)
  52   2              {
  53   3                  slidV[i + 1] = slidV[i];
  54   3              }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 12:18:21 PAGE 2   

  55   2              slidV[0] = getVolt();
  56   2              for (i = 0; i < 5; i++)
  57   2              {
  58   3                  num += slidV[i];
  59   3              }
  60   2          }
  61   1          return ((uchar)num / 5);
  62   1      }
  63          
  64          // 限速滤波
  65          uchar speedFilt()
  66          {
  67   1          uchar V[3];
  68   1          V[0] = getVolt();
  69   1          V[1] = getVolt();
  70   1          if (abs(V[0] - V[1]) <= DV)
  71   1          {
  72   2              return V[1];
  73   2          }
  74   1          else
  75   1          {
  76   2              V[2] = getVolt();
  77   2              if (abs(V[1] - V[2]) <= DV)
  78   2              {
  79   3                  return V[2];
  80   3              }
  81   2              else
  82   2              {
  83   3                  return ((V[2] + V[3]) / 2);
  84   3              }
  85   2          }
  86   1      }
  87          
  88          // 限幅滤波
  89          uchar amplimtFilt()
  90          {
  91   1          uchar tmp = getVolt();
  92   1          if (abs(volt - tmp) < LV)
  93   1          {
  94   2              return tmp;
  95   2          }
  96   1          else
  97   1          {
  98   2              return volt;
  99   2          }
 100   1      }
 101          
 102          // 中位数滤波
 103          uchar midFilt()
 104          {
 105   1          uchar V[5];
 106   1          uchar i, j;
 107   1          uchar tmp = 0;
 108   1          for (i = 0; i < 5; i++)
 109   1          {
 110   2              V[i] = getVolt();
 111   2          }
 112   1          for (i = 1; i < 5; i++)
 113   1          {
 114   2              for (j = 0; j < 5 - i; j++)
 115   2              {
 116   3                  if (V[j] > V[j + 1])
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 12:18:21 PAGE 3   

 117   3                  {
 118   4                      tmp = V[j];
 119   4                      V[j] = V[j + 1];
 120   4                      V[j + 1] = tmp;
 121   4                  }
 122   3              }
 123   2          }
 124   1          return V[2];
 125   1      }
 126          
 127          // 中位平均滤波
 128          uchar midavgFilt()
 129          {
 130   1          uchar V[5];
 131   1          uchar i, j;
 132   1          uchar tmp = 0;
 133   1          int num = 0;
 134   1          for (i = 0; i < 5; i++)
 135   1          {
 136   2              V[i] = getVolt();
 137   2          }
 138   1          for (i = 1; i < 5; i++)
 139   1          {
 140   2              for (j = 0; j < 5 - i; j++)
 141   2              {
 142   3                  if (V[j] > V[j + 1])
 143   3                  {
 144   4                      tmp = V[j];
 145   4                      V[j] = V[j + 1];
 146   4                      V[j + 1] = tmp;
 147   4                  }
 148   3              }
 149   2          }
 150   1          num = (V[1] + V[2] + V[3]);
 151   1          return ((uchar)(num / 3));
 152   1      }
 153          
 154          // 限幅平均滤波
 155          uchar limtvgFilt()
 156          {
 157   1          uchar V[5];
 158   1          int num = 0;
 159   1          int i = 0;
 160   1          V[0] = volt;
 161   1          for (i = 1; i < 5; i++)
 162   1          {
 163   2              V[i] = getVolt();
 164   2              if (abs(V[i] - V[i - 1]) > LV)
 165   2              {
 166   3                   V[i] = V[i - 1];
 167   3              }
 168   2          }
 169   1          for (i = 0; i < 5; i++)
 170   1          {
 171   2              num += V[i];
 172   2          }
 173   1          return ((uchar)(num / 5));
 174   1      }
 175          
 176          // 一阶滞后滤波
 177          uchar onlastFilt()
 178          {
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 12:18:21 PAGE 4   

 179   1          return ((1 - LASTA) * volt + LASTA * getVolt());
 180   1      }
 181          
 182          // 加权递推
 183          uchar weislidFlit()
 184          {
 185   1          uchar i = 0;
 186   1          uchar tmp;
 187   1          int num;
 188   1          if (tmpPort != port)
 189   1          {
 190   2              tmp = getVolt();
 191   2              for (i = 0; i < 5; i++)
 192   2              {
 193   3                  slidV[i] = tmp;
 194   3              }
 195   2              return tmp;
 196   2          }
 197   1          else
 198   1          {
 199   2              for (i = 4; i > 0; i--)
 200   2              {
 201   3                  slidV[i + 1] = slidV[i];
 202   3              }
 203   2              slidV[0] = getVolt();
 204   2              for (i = 0; i < 5; i++)
 205   2              {
 206   3                  num += (i + 1) * slidV[i];
 207   3              }
 208   2          }
 209   1          return ((uchar)num / (15 * 5));
 210   1      }
 211          
 212          // 消抖滤波
 213          uchar debFilt()
 214          {
 215   1          if (volt = getVolt())
 216   1          {
 217   2              debnum = 0;
 218   2          }
 219   1          else
 220   1          {
 221   2              debnum++;
 222   2          }
 223   1          if (debnum > MAXDEB)
 224   1          {
 225   2              return getVolt();
 226   2          }
 227   1          else
 228   1          {
 229   2              return volt;
 230   2          }
 231   1      }
 232          // 限幅消抖滤波
 233          uchar debavgFilt()
 234          {
 235   1          uchar tmp = getVolt();
 236   1          if (volt = tmp)
 237   1          {
 238   2              debnum = 0;
 239   2          }
 240   1          else
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 12:18:21 PAGE 5   

 241   1          {
 242   2              if (abs(volt - tmp) < LV)
 243   2              {
 244   3                  debnum++;
 245   3              }
 246   2          }
 247   1          if (debnum > MAXDEB)
 248   1          {
 249   2              return tmp;
 250   2          }
 251   1          else
 252   1          {
 253   2              return volt;
 254   2          }
 255   1      }
 256          
 257          uchar (*filtFuns[11])() =
 258              {
 259                  avgFilt,
 260                  slideavgFilt,
 261                  speedFilt,
 262                  amplimtFilt,
 263                  midFilt,
 264                  midavgFilt,
 265                  limtvgFilt,
 266                  onlastFilt,
 267                  weislidFlit,
 268                  debFilt,
 269                  debavgFilt,
 270          };


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    934    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
