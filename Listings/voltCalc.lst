C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/14/2022 12:13:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE VOLTCALC
OBJECT MODULE PLACED IN .\Objects\voltCalc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE voltCalc.c OPTIMIZE(8,SPEED) PRINT(.\Listings\voltCalc.lst) TABS(2) OBJE
                    -CT(.\Objects\voltCalc.obj)

line level    source

   1          #define uchar unsigned char
   2          #include <AT89X52.h>
   3          #include <absacc.h>
   4          #include <math.h>
   5          #include "ADC0808.h"
   6          #include "delay.h"
   7          #define DV 5
   8          #define LV 50
   9          #define LASTA 0.3
  10          #define MAXDEB 5
  11          extern uchar volt;
  12          extern uchar port;
  13          uchar slidV[5] = {0, 0, 0, 0, 0};
  14          uchar weight[5] = {1, 2, 4, 8, 16};
  15          uchar debnum = 0;
  16          
  17          /// @brief 平均值滤波
  18          /// @return 滤波后模拟量数值
  19          uchar avgFilt()
  20          {
  21   1          uchar V[5];
  22   1          int num = 0;
  23   1          int i = 0;
  24   1          for (i = 0; i < 5; i++)
  25   1          {
  26   2              delay_nms(50);
  27   2              V[i] = getVolt();
  28   2          }
  29   1          for (i = 0; i < 5; i++)
  30   1          {
  31   2              num += V[i];
  32   2          }
  33   1          return ((uchar)(num / 5));
  34   1      }
  35          
  36          /// @brief 滑动平均滤波
  37          /// @return 滤波后模拟量数值
  38          uchar slideavgFilt()
  39          {
  40   1          static uchar p = 0;
  41   1          int num = 0;
  42   1          int i;
  43   1          p++;
  44   1          if (p > 4)
  45   1          {
  46   2              p = 0;
  47   2          }
  48   1          slidV[p] = getVolt();
  49   1          for (i = 0; i < 5; i++)
  50   1          {
  51   2              num += slidV[i];
  52   2          }
  53   1          return ((uchar)(num / 5));
  54   1      }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/14/2022 12:13:10 PAGE 2   

  55          
  56          /// @brief 限速滤波
  57          /// @return 滤波后模拟量数值
  58          uchar speedFilt()
  59          {
  60   1          uchar V[3];
  61   1          V[0] = getVolt();
  62   1          V[1] = getVolt();
  63   1          if (abs(V[0] - V[1]) <= DV)
  64   1          {
  65   2              return V[1];
  66   2          }
  67   1          else
  68   1          {
  69   2              V[2] = getVolt();
  70   2              if (abs(V[1] - V[2]) <= DV)
  71   2              {
  72   3                  return V[2];
  73   3              }
  74   2              else
  75   2              {
  76   3                  return ((V[1] + V[2]) / 2);
  77   3              }
  78   2          }
  79   1      }
  80          
  81          /// @brief 限幅滤波
  82          /// @return 滤波后模拟量数值
  83          uchar amplimtFilt()
  84          {
  85   1          uchar tmp = getVolt();
  86   1          if (abs(volt - tmp) < LV)
  87   1          {
  88   2              return tmp;
  89   2          }
  90   1          else
  91   1          {
  92   2              return volt;
  93   2          }
  94   1      }
  95          
  96          /// @brief 中位数滤波
  97          /// @return 滤波后模拟量数值
  98          uchar midFilt()
  99          {
 100   1          uchar V[5];
 101   1          uchar i, j;
 102   1          uchar tmp = 0;
 103   1          for (i = 0; i < 5; i++)
 104   1          {
 105   2              V[i] = getVolt();
 106   2          }
 107   1          for (i = 1; i < 5; i++)
 108   1          {
 109   2              for (j = 0; j < 5 - i; j++)
 110   2              {
 111   3                  if (V[j] > V[j + 1])
 112   3                  {
 113   4                      tmp = V[j];
 114   4                      V[j] = V[j + 1];
 115   4                      V[j + 1] = tmp;
 116   4                  }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/14/2022 12:13:10 PAGE 3   

 117   3              }
 118   2          }
 119   1          return V[2];
 120   1      }
 121          
 122          /// @brief 中位平均滤波
 123          /// @return 滤波后模拟量数值
 124          uchar midavgFilt()
 125          {
 126   1          uchar V[5];
 127   1          uchar i, j;
 128   1          uchar tmp = 0;
 129   1          int num = 0;
 130   1          for (i = 0; i < 5; i++)
 131   1          {
 132   2              V[i] = getVolt();
 133   2          }
 134   1          for (i = 1; i < 5; i++)
 135   1          {
 136   2              for (j = 0; j < 5 - i; j++)
 137   2              {
 138   3                  if (V[j] > V[j + 1])
 139   3                  {
 140   4                      tmp = V[j];
 141   4                      V[j] = V[j + 1];
 142   4                      V[j + 1] = tmp;
 143   4                  }
 144   3              }
 145   2          }
 146   1          num = (V[1] + V[2] + V[3]);
 147   1          return ((uchar)(num / 3));
 148   1      }
 149          
 150          /// @brief 限幅平均滤波
 151          /// @return 滤波后模拟量数值
 152          uchar limtvgFilt()
 153          {
 154   1          uchar V[5];
 155   1          int num = 0;
 156   1          int i = 0;
 157   1          V[0] = volt;
 158   1          for (i = 1; i < 5; i++)
 159   1          {
 160   2              V[i] = getVolt();
 161   2              if (abs(V[i] - V[i - 1]) > LV)
 162   2              {
 163   3                  V[i] = V[i - 1];
 164   3              }
 165   2          }
 166   1          for (i = 0; i < 5; i++)
 167   1          {
 168   2              num += V[i];
 169   2          }
 170   1          return ((uchar)(num / 5));
 171   1      }
 172          
 173          /// @brief 一阶滞后滤波
 174          /// @return 滤波后模拟量数值
 175          uchar onlastFilt()
 176          {
 177   1          return ((1 - LASTA) * volt + LASTA * getVolt());
 178   1      }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/14/2022 12:13:10 PAGE 4   

 179          
 180          /// @brief 加权递推滤波
 181          /// @return 滤波后模拟量数值
 182          uchar weislidFlit()
 183          {
 184   1          static uchar p = 0;
 185   1          int num = 0;
 186   1          int i;
 187   1          slidV[p] = getVolt();
 188   1          p++;
 189   1          if (p > 4)
 190   1          {
 191   2              p = 0;
 192   2          }
 193   1          for (i = 0; i < 5; i++)
 194   1          {
 195   2              num += weight[i] * (int)slidV[p];
 196   2              p++;
 197   2              if (p > 4)
 198   2              {
 199   3                  p = 0;
 200   3              }
 201   2          }
 202   1          return ((uchar)(num / 31));
 203   1      }
 204          
 205          /// @brief 消抖滤波
 206          /// @return 滤波后模拟量数值
 207          uchar debFilt()
 208          {
 209   1          uchar tmp = getVolt();
 210   1          if (volt == tmp)
 211   1          {
 212   2              debnum = 0;
 213   2          }
 214   1          else
 215   1          {
 216   2              debnum++;
 217   2          }
 218   1          if (debnum > MAXDEB)
 219   1          {
 220   2              debnum = 0;
 221   2              return tmp;
 222   2          }
 223   1          else
 224   1          {
 225   2              return volt;
 226   2          }
 227   1      }
 228          
 229          /// @brief 限幅消抖滤波
 230          /// @return 滤波后模拟量数值
 231          uchar debavgFilt()
 232          {
 233   1          uchar tmp = getVolt();
 234   1          if (volt == tmp)
 235   1          {
 236   2              debnum = 0;
 237   2          }
 238   1          else
 239   1          {
 240   2              if (abs(volt - tmp) < LV)
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/14/2022 12:13:10 PAGE 5   

 241   2              {
 242   3                  debnum++;
 243   3              }
 244   2          }
 245   1          if (debnum > MAXDEB)
 246   1          {
 247   2              debnum = 0;
 248   2              return tmp;
 249   2          }
 250   1          else
 251   1          {
 252   2              return volt;
 253   2          }
 254   1      }
 255          
 256          /// @brief 用于快速切换滤波方式的函数指针数组
 257          uchar (*filtFuns[11])() =
 258              {
 259                  avgFilt,
 260                  slideavgFilt,
 261                  speedFilt,
 262                  amplimtFilt,
 263                  midFilt,
 264                  midavgFilt,
 265                  limtvgFilt,
 266                  onlastFilt,
 267                  weislidFlit,
 268                  debFilt,
 269                  debavgFilt,
 270          };


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    888    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
