C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 00:37:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE VOLTCALC
OBJECT MODULE PLACED IN .\Objects\voltCalc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE voltCalc.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -voltCalc.lst) TABS(2) OBJECT(.\Objects\voltCalc.obj)

line level    source

   1          #define uchar unsigned char
   2          #include <AT89X52.h>
   3          #include <absacc.h>
   4          #include <math.h>
   5          #include "ADC0808.h"
   6          
   7          #define dV 20
   8          #define lastA 0.3
   9          #define maxDeb 5
  10          extern uchar volt;
  11          extern uchar port;
  12          
  13          // 平均值滤波
  14          uchar avgFilt()
  15          {
  16   1          uchar V[5];
  17   1          int num = 0;
  18   1          uchar i = 0;
  19   1          for (i = 0; i < 5; i++)
  20   1          {
  21   2              V[i] = getVolt();
  22   2          }
  23   1          for (i = 0; i < 5; i++)
  24   1          {
  25   2              num += V[i];
  26   2          }
  27   1          return (num/5);
  28   1      }
  29          
  30          // 滑动平均滤波
  31          uchar slideavgFilt()
  32          {
  33   1          static uchar V[5] = {0, 0, 0, 0, 0};
  34   1          static tmpPort = 0;
  35   1          uchar i = 0;
  36   1          int num;
  37   1          if (tmpPort != port)
  38   1          {
  39   2              for (i = 0; i < 5; i++)
  40   2              {
  41   3                  V[i] = 0;
  42   3              }
  43   2          }
  44   1          for (i = 0; i < 4; i++)
  45   1          {
  46   2              V[i + 1] = V[i];
  47   2          }
  48   1          V[0] = getVolt();
  49   1          for (i = 0; i < 5; i++)
  50   1          {
  51   2              num += V[i];
  52   2          }
  53   1          return ((uchar)num / 5);
  54   1      }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 00:37:34 PAGE 2   

  55          
  56          // 限速滤波
  57          uchar speedFilt()
  58          {
  59   1          uchar V[3];
  60   1          V[0] = getVolt();
  61   1          V[1] = getVolt();
  62   1          if (abs(V[0] - V[1]) <= dV)
  63   1          {
  64   2              return V[1];
  65   2          }
  66   1          else
  67   1          {
  68   2              V[2] = getVolt();
  69   2              if (abs(V[1] - V[2]) <= dV)
  70   2              {
  71   3                  return V[2];
  72   3              }
  73   2              else
  74   2              {
  75   3                  return (V[2] + V[3]) / 2;
  76   3              }
  77   2          }
  78   1      }
  79          
  80          // 限幅滤波
  81          uchar amplimtFilt()
  82          {
  83   1          uchar tmp = getVolt();
  84   1          if (abs(volt - tmp) < 10)
  85   1          {
  86   2              return tmp;
  87   2          }
  88   1          else
  89   1          {
  90   2              return volt;
  91   2          }
  92   1      }
  93          
  94          // 中位数滤波
  95          uchar midFilt()
  96          {
  97   1          uchar V[5];
  98   1          uchar i, j;
  99   1          uchar tmp = 0;
 100   1          for (i = 0; i < 5; i++)
 101   1          {
 102   2              V[i] = getVolt();
 103   2          }
 104   1          for (i = 4; i > 0; i--)
 105   1          {
 106   2              for (j = 0; j < i; i++)
 107   2              {
 108   3                  if (V[j] > V[j + 1])
 109   3                  {
 110   4                      tmp = V[j];
 111   4                      V[j] = V[j + 1];
 112   4                      V[j + 1] = tmp;
 113   4                  }
 114   3              }
 115   2          }
 116   1          return V[2];
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 00:37:34 PAGE 3   

 117   1      }
 118          
 119          // 中位平均滤波
 120          uchar midavgFilt()
 121          {
 122   1          uchar V[5];
 123   1          uchar i, j;
 124   1          uchar tmp = 0;
 125   1          for (i = 0; i < 5; i++)
 126   1          {
 127   2              V[i] = getVolt();
 128   2          }
 129   1          for (i = 4; i > 0; i--)
 130   1          {
 131   2              for (j = 0; j < i; i++)
 132   2              {
 133   3                  if (V[j] > V[j + 1])
 134   3                  {
 135   4                      tmp = V[j];
 136   4                      V[j] = V[j + 1];
 137   4                      V[j + 1] = tmp;
 138   4                  }
 139   3              }
 140   2          }
 141   1          return (V[1] + V[2] + V[3]) / 2;
 142   1      }
 143          
 144          // 限幅平均滤波
 145          uchar limtvgFilt()
 146          {
 147   1          uchar V[5];
 148   1          uchar i;
 149   1          uchar tmp = 0;
 150   1          uchar num;
 151   1          V[0] = volt;
 152   1          i = 1;
 153   1          while (i > 5)
 154   1          {
 155   2              if (abs(V[i] - V[i - 1]) < 10)
 156   2              {
 157   3                  V[i] = getVolt();
 158   3              }
 159   2              else
 160   2              {
 161   3                  V[i] = V[i - 1];
 162   3              }
 163   2              i++;
 164   2          }
 165   1          for (i = 0; i < 5; i++)
 166   1          {
 167   2              num += V[i];
 168   2          }
 169   1          return ((uchar)num / 5);
 170   1      }
 171          
 172          // 一阶滞后滤波
 173          uchar onlastFilt()
 174          {
 175   1          return ((1 - lastA) * volt + lastA * getVolt());
 176   1      }
 177          
 178          //加权递推
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 00:37:34 PAGE 4   

 179          uchar weislidFlit()
 180          {
 181   1          static uchar V[5] = {0, 0, 0, 0, 0};
 182   1          static tmpPort = 0;
 183   1          uchar i = 0;
 184   1          int num;
 185   1          if (tmpPort != port)
 186   1          {
 187   2              for (i = 0; i < 5; i++)
 188   2              {
 189   3                  V[i] = 0;
 190   3              }
 191   2          }
 192   1          for (i = 0; i < 4; i++)
 193   1          {
 194   2              V[i + 1] = V[i];
 195   2          }
 196   1          V[0] = getVolt();
 197   1          for (i = 0; i < 5; i++)
 198   1          {
 199   2              num += (i+1)*V[i];
 200   2          }
 201   1          return ((uchar)num / (15*5));
 202   1      }
 203          
 204          // 消抖滤波
 205          uchar debFilt()
 206          {
 207   1          static uchar i = 0;
 208   1          if (volt = getVolt())
 209   1          {
 210   2              i = 0;
 211   2          }
 212   1          else
 213   1          {
 214   2              i++;
 215   2          }
 216   1          if (i > maxDeb)
 217   1          {
 218   2              return getVolt();
 219   2          }
 220   1          else
 221   1          {
 222   2              return volt;
 223   2          }
 224   1      }
 225          // 限幅消抖滤波
 226          uchar debavgFilt()
 227          {
 228   1          static uchar i = 0;
 229   1          uchar tmp = getVolt();
 230   1          if (volt = tmp)
 231   1          {
 232   2              i = 0;
 233   2          }
 234   1          else
 235   1          {
 236   2              if (abs(volt - tmp) < 10)
 237   2              {
 238   3                  i++;
 239   3              }
 240   2          }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 00:37:34 PAGE 5   

 241   1          if (i > maxDeb)
 242   1          {
 243   2              return tmp;
 244   2          }
 245   1          else
 246   1          {
 247   2              return volt;
 248   2          }
 249   1      }
 250          
 251          uchar (*filtFuns[11]) () = 
 252          {
 253          avgFilt,
 254          slideavgFilt,
 255          speedFilt,
 256          amplimtFilt,
 257          midFilt,
 258          midavgFilt,
 259          limtvgFilt,
 260          onlastFilt,
 261          weislidFlit,
 262          debFilt,
 263          debavgFilt,
 264          };


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    858    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49      39
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
