C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/13/2022 12:43:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE VOLTCALC
OBJECT MODULE PLACED IN .\Objects\voltCalc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE voltCalc.c OPTIMIZE(8,SPEED) PRINT(.\Listings\voltCalc.lst) TABS(2) OBJE
                    -CT(.\Objects\voltCalc.obj)

line level    source

   1          #define uchar unsigned char
   2          #include <AT89X52.h>
   3          #include <absacc.h>
   4          #include <math.h>
   5          #include "ADC0808.h"
   6          #include "delay.h"
   7          #define DV 20
   8          #define LV 50
   9          #define LASTA 0.3
  10          #define MAXDEB 5
  11          extern uchar volt;
  12          extern uchar port;
  13          uchar tmpPort = 200;
  14          uchar slidV[5] = {0,0,0,0,0};
  15          uchar debnum = 0;
  16          
  17          /// @brief 平均值滤波
  18          /// @return 滤波后模拟量数值
  19          uchar avgFilt()
  20          {
  21   1          uchar V[5];
  22   1          int num = 0;
  23   1          int i = 0;
  24   1          for (i = 0; i < 5; i++)
  25   1          {
  26   2              V[i] = getVolt();
  27   2          }
  28   1          for (i = 0; i < 5; i++)
  29   1          {
  30   2              num += V[i];
  31   2          }
  32   1          //return ((uchar)(num / 5));
  33   1          return 0;//debug
  34   1      }
  35          
  36          
  37          /// @brief 滑动平均滤波
  38          /// @return 滤波后模拟量数值
  39          uchar slideavgFilt()
  40          {
  41   1          uchar i = 0;
  42   1          uchar tmp;
  43   1          int num;
  44   1          if (tmpPort != port)
  45   1          {
  46   2              delay_nms(20);
  47   2              tmp = getVolt();
  48   2              for (i = 0; i < 5; i++)
  49   2              {
  50   3                  slidV[i] = tmp;
  51   3              }
  52   2              return tmp;
  53   2          }
  54   1          else
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/13/2022 12:43:57 PAGE 2   

  55   1          {
  56   2              for (i = 4; i > 0; i--)
  57   2              {
  58   3                  slidV[i + 1] = slidV[i];
  59   3              }
  60   2              slidV[0] = getVolt();
  61   2              for (i = 0; i < 5; i++)
  62   2              {
  63   3                  num += slidV[i];
  64   3              }
  65   2          }
  66   1          return ((uchar)num / 5);
  67   1      }
  68          
  69          
  70          /// @brief 限速滤波
  71          /// @return 滤波后模拟量数值
  72          uchar speedFilt()
  73          {
  74   1          uchar V[3];
  75   1          V[0] = getVolt();
  76   1          V[1] = getVolt();
  77   1          if (abs(V[0] - V[1]) <= DV)
  78   1          {
  79   2              return V[1];
  80   2          }
  81   1          else
  82   1          {
  83   2              V[2] = getVolt();
  84   2              if (abs(V[1] - V[2]) <= DV)
  85   2              {
  86   3                  return V[2];
  87   3              }
  88   2              else
  89   2              {
  90   3                  return ((V[2] + V[3]) / 2);
  91   3              }
  92   2          }
  93   1      }
  94          
  95          /// @brief 限幅滤波
  96          /// @return 滤波后模拟量数值
  97          uchar amplimtFilt()
  98          {
  99   1          uchar tmp = getVolt();
 100   1          if (abs(volt - tmp) < LV)
 101   1          {
 102   2              return tmp;
 103   2          }
 104   1          else
 105   1          {
 106   2              return volt;
 107   2          }
 108   1      }
 109          
 110          /// @brief 中位数滤波
 111          /// @return 滤波后模拟量数值
 112          uchar midFilt()
 113          {
 114   1          uchar V[5];
 115   1          uchar i, j;
 116   1          uchar tmp = 0;
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/13/2022 12:43:57 PAGE 3   

 117   1          for (i = 0; i < 5; i++)
 118   1          {
 119   2              V[i] = getVolt();
 120   2          }
 121   1          for (i = 1; i < 5; i++)
 122   1          {
 123   2              for (j = 0; j < 5 - i; j++)
 124   2              {
 125   3                  if (V[j] > V[j + 1])
 126   3                  {
 127   4                      tmp = V[j];
 128   4                      V[j] = V[j + 1];
 129   4                      V[j + 1] = tmp;
 130   4                  }
 131   3              }
 132   2          }
 133   1          return V[2];
 134   1      }
 135          
 136          /// @brief 中位平均滤波
 137          /// @return 滤波后模拟量数值
 138          uchar midavgFilt()
 139          {
 140   1          uchar V[5];
 141   1          uchar i, j;
 142   1          uchar tmp = 0;
 143   1          int num = 0;
 144   1          for (i = 0; i < 5; i++)
 145   1          {
 146   2              V[i] = getVolt();
 147   2          }
 148   1          for (i = 1; i < 5; i++)
 149   1          {
 150   2              for (j = 0; j < 5 - i; j++)
 151   2              {
 152   3                  if (V[j] > V[j + 1])
 153   3                  {
 154   4                      tmp = V[j];
 155   4                      V[j] = V[j + 1];
 156   4                      V[j + 1] = tmp;
 157   4                  }
 158   3              }
 159   2          }
 160   1          num = (V[1] + V[2] + V[3]);
 161   1          return ((uchar)(num / 3));
 162   1      }
 163          
 164          /// @brief 限幅平均滤波
 165          /// @return 滤波后模拟量数值
 166          uchar limtvgFilt()
 167          {
 168   1          uchar V[5];
 169   1          int num = 0;
 170   1          int i = 0;
 171   1          V[0] = volt;
 172   1          for (i = 1; i < 5; i++)
 173   1          {
 174   2              V[i] = getVolt();
 175   2              if (abs(V[i] - V[i - 1]) > LV)
 176   2              {
 177   3                   V[i] = V[i - 1];
 178   3              }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/13/2022 12:43:57 PAGE 4   

 179   2          }
 180   1          for (i = 0; i < 5; i++)
 181   1          {
 182   2              num += V[i];
 183   2          }
 184   1          return ((uchar)(num / 5));
 185   1      }
 186          
 187          /// @brief 一阶滞后滤波
 188          /// @return 滤波后模拟量数值
 189          uchar onlastFilt()
 190          {
 191   1          return ((1 - LASTA) * volt + LASTA * getVolt());
 192   1      }
 193          
 194          /// @brief 加权递推滤波
 195          /// @return 滤波后模拟量数值
 196          uchar weislidFlit()
 197          {
 198   1          uchar i = 0;
 199   1          uchar tmp;
 200   1          int num;
 201   1          if (tmpPort != port)
 202   1          {
 203   2              tmp = getVolt();
 204   2              for (i = 0; i < 5; i++)
 205   2              {
 206   3                  slidV[i] = tmp;
 207   3              }
 208   2              return tmp;
 209   2          }
 210   1          else
 211   1          {
 212   2              for (i = 4; i > 0; i--)
 213   2              {
 214   3                  slidV[i + 1] = slidV[i];
 215   3              }
 216   2              slidV[0] = getVolt();
 217   2              for (i = 0; i < 5; i++)
 218   2              {
 219   3                  num += (i + 1) * slidV[i];
 220   3              }
 221   2          }
 222   1          return ((uchar)num / (15 * 5));
 223   1      }
 224          
 225          /// @brief 消抖滤波
 226          /// @return 滤波后模拟量数值
 227          uchar debFilt()
 228          {
 229   1          uchar tmp = getVolt();
 230   1          if (volt == tmp)
 231   1          {
 232   2              debnum = 0;
 233   2          }
 234   1          else
 235   1          {
 236   2              debnum++;
 237   2          }
 238   1          if (debnum > MAXDEB)
 239   1          {
 240   2              debnum = 0;
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/13/2022 12:43:57 PAGE 5   

 241   2              return tmp;
 242   2          }
 243   1          else
 244   1          {
 245   2              return volt;
 246   2          }
 247   1      }
 248          
 249          /// @brief 限幅消抖滤波
 250          /// @return 滤波后模拟量数值
 251          uchar debavgFilt()
 252          {
 253   1          uchar tmp = getVolt();
 254   1          if (volt == tmp)
 255   1          {
 256   2              debnum = 0;
 257   2          }
 258   1          else
 259   1          {
 260   2              if (abs(volt - tmp) < LV)
 261   2              {
 262   3                  debnum++;
 263   3              }
 264   2          }
 265   1          if (debnum > MAXDEB)
 266   1          {
 267   2              debnum = 0;
 268   2              return tmp;
 269   2          }
 270   1          else
 271   1          {
 272   2              return volt;
 273   2          }
 274   1      }
 275          
 276          /// @brief 用于快速切换滤波方式的函数指针数组
 277          uchar (*filtFuns[11])() =
 278              {
 279                  avgFilt,
 280                  slideavgFilt,
 281                  speedFilt,
 282                  amplimtFilt,
 283                  midFilt,
 284                  midavgFilt,
 285                  limtvgFilt,
 286                  onlastFilt,
 287                  weislidFlit,
 288                  debFilt,
 289                  debavgFilt,
 290          };


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    930    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
