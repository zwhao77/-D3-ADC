C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 16:15:20 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE VOLTCALC
OBJECT MODULE PLACED IN .\Objects\voltCalc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE voltCalc.c OPTIMIZE(8,SPEED) PRINT(.\Listings\voltCalc.lst) TABS(2) OBJE
                    -CT(.\Objects\voltCalc.obj)

line level    source

   1          #define uchar unsigned char
   2          #include <AT89X52.h>
   3          #include <absacc.h>
   4          #include <math.h>
   5          #include "ADC0808.h"
   6          #include "delay.h"
   7          #define DV 20
   8          #define LV 50
   9          #define LASTA 0.3
  10          #define MAXDEB 5
  11          extern uchar volt;
  12          extern uchar port;
  13          uchar tmpPort = 200;
  14          uchar slidV[5];
  15          uchar debnum = 0;
  16          
  17          /// @brief 平均值滤波
  18          /// @return 滤波后模拟量数值
  19          uchar avgFilt()
  20          {
  21   1          uchar V[5];
  22   1          int num = 0;
  23   1          int i = 0;
  24   1          for (i = 0; i < 5; i++)
  25   1          {
  26   2              V[i] = getVolt();
  27   2          }
  28   1          for (i = 0; i < 5; i++)
  29   1          {
  30   2              num += V[i];
  31   2          }
  32   1          return ((uchar)(num / 5));
  33   1      }
  34          
  35          
  36          /// @brief 滑动平均滤波
  37          /// @return 滤波后模拟量数值
  38          uchar slideavgFilt()
  39          {
  40   1          uchar i = 0;
  41   1          uchar tmp;
  42   1          int num;
  43   1          if (tmpPort != port)
  44   1          {
  45   2              delay_nms(20);
  46   2              tmp = getVolt();
  47   2              for (i = 0; i < 5; i++)
  48   2              {
  49   3                  slidV[i] = tmp;
  50   3              }
  51   2              return tmp;
  52   2          }
  53   1          else
  54   1          {
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 16:15:20 PAGE 2   

  55   2              for (i = 4; i > 0; i--)
  56   2              {
  57   3                  slidV[i + 1] = slidV[i];
  58   3              }
  59   2              slidV[0] = getVolt();
  60   2              for (i = 0; i < 5; i++)
  61   2              {
  62   3                  num += slidV[i];
  63   3              }
  64   2          }
  65   1          return ((uchar)num / 5);
  66   1      }
  67          
  68          
  69          /// @brief 限速滤波
  70          /// @return 滤波后模拟量数值
  71          uchar speedFilt()
  72          {
  73   1          uchar V[3];
  74   1          V[0] = getVolt();
  75   1          V[1] = getVolt();
  76   1          if (abs(V[0] - V[1]) <= DV)
  77   1          {
  78   2              return V[1];
  79   2          }
  80   1          else
  81   1          {
  82   2              V[2] = getVolt();
  83   2              if (abs(V[1] - V[2]) <= DV)
  84   2              {
  85   3                  return V[2];
  86   3              }
  87   2              else
  88   2              {
  89   3                  return ((V[2] + V[3]) / 2);
  90   3              }
  91   2          }
  92   1      }
  93          
  94          /// @brief 限幅滤波
  95          /// @return 滤波后模拟量数值
  96          uchar amplimtFilt()
  97          {
  98   1          uchar tmp = getVolt();
  99   1          if (abs(volt - tmp) < LV)
 100   1          {
 101   2              return tmp;
 102   2          }
 103   1          else
 104   1          {
 105   2              return volt;
 106   2          }
 107   1      }
 108          
 109          /// @brief 中位数滤波
 110          /// @return 滤波后模拟量数值
 111          uchar midFilt()
 112          {
 113   1          uchar V[5];
 114   1          uchar i, j;
 115   1          uchar tmp = 0;
 116   1          for (i = 0; i < 5; i++)
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 16:15:20 PAGE 3   

 117   1          {
 118   2              V[i] = getVolt();
 119   2          }
 120   1          for (i = 1; i < 5; i++)
 121   1          {
 122   2              for (j = 0; j < 5 - i; j++)
 123   2              {
 124   3                  if (V[j] > V[j + 1])
 125   3                  {
 126   4                      tmp = V[j];
 127   4                      V[j] = V[j + 1];
 128   4                      V[j + 1] = tmp;
 129   4                  }
 130   3              }
 131   2          }
 132   1          return V[2];
 133   1      }
 134          
 135          /// @brief 中位平均滤波
 136          /// @return 滤波后模拟量数值
 137          uchar midavgFilt()
 138          {
 139   1          uchar V[5];
 140   1          uchar i, j;
 141   1          uchar tmp = 0;
 142   1          int num = 0;
 143   1          for (i = 0; i < 5; i++)
 144   1          {
 145   2              V[i] = getVolt();
 146   2          }
 147   1          for (i = 1; i < 5; i++)
 148   1          {
 149   2              for (j = 0; j < 5 - i; j++)
 150   2              {
 151   3                  if (V[j] > V[j + 1])
 152   3                  {
 153   4                      tmp = V[j];
 154   4                      V[j] = V[j + 1];
 155   4                      V[j + 1] = tmp;
 156   4                  }
 157   3              }
 158   2          }
 159   1          num = (V[1] + V[2] + V[3]);
 160   1          return ((uchar)(num / 3));
 161   1      }
 162          
 163          /// @brief 限幅平均滤波
 164          /// @return 滤波后模拟量数值
 165          uchar limtvgFilt()
 166          {
 167   1          uchar V[5];
 168   1          int num = 0;
 169   1          int i = 0;
 170   1          V[0] = volt;
 171   1          for (i = 1; i < 5; i++)
 172   1          {
 173   2              V[i] = getVolt();
 174   2              if (abs(V[i] - V[i - 1]) > LV)
 175   2              {
 176   3                   V[i] = V[i - 1];
 177   3              }
 178   2          }
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 16:15:20 PAGE 4   

 179   1          for (i = 0; i < 5; i++)
 180   1          {
 181   2              num += V[i];
 182   2          }
 183   1          return ((uchar)(num / 5));
 184   1      }
 185          
 186          /// @brief 一阶滞后滤波
 187          /// @return 滤波后模拟量数值
 188          uchar onlastFilt()
 189          {
 190   1          return ((1 - LASTA) * volt + LASTA * getVolt());
 191   1      }
 192          
 193          /// @brief 加权递推滤波
 194          /// @return 滤波后模拟量数值
 195          uchar weislidFlit()
 196          {
 197   1          uchar i = 0;
 198   1          uchar tmp;
 199   1          int num;
 200   1          if (tmpPort != port)
 201   1          {
 202   2              tmp = getVolt();
 203   2              for (i = 0; i < 5; i++)
 204   2              {
 205   3                  slidV[i] = tmp;
 206   3              }
 207   2              return tmp;
 208   2          }
 209   1          else
 210   1          {
 211   2              for (i = 4; i > 0; i--)
 212   2              {
 213   3                  slidV[i + 1] = slidV[i];
 214   3              }
 215   2              slidV[0] = getVolt();
 216   2              for (i = 0; i < 5; i++)
 217   2              {
 218   3                  num += (i + 1) * slidV[i];
 219   3              }
 220   2          }
 221   1          return ((uchar)num / (15 * 5));
 222   1      }
 223          
 224          /// @brief 消抖滤波
 225          /// @return 滤波后模拟量数值
 226          uchar debFilt()
 227          {
 228   1          if (volt = getVolt())
 229   1          {
 230   2              debnum = 0;
 231   2          }
 232   1          else
 233   1          {
 234   2              debnum++;
 235   2          }
 236   1          if (debnum > MAXDEB)
 237   1          {
 238   2              return getVolt();
 239   2          }
 240   1          else
C51 COMPILER V9.60.0.0   VOLTCALC                                                          12/12/2022 16:15:20 PAGE 5   

 241   1          {
 242   2              return volt;
 243   2          }
 244   1      }
 245          
 246          /// @brief 限幅消抖滤波
 247          /// @return 滤波后模拟量数值
 248          uchar debavgFilt()
 249          {
 250   1          uchar tmp = getVolt();
 251   1          if (volt = tmp)
 252   1          {
 253   2              debnum = 0;
 254   2          }
 255   1          else
 256   1          {
 257   2              if (abs(volt - tmp) < LV)
 258   2              {
 259   3                  debnum++;
 260   3              }
 261   2          }
 262   1          if (debnum > MAXDEB)
 263   1          {
 264   2              return tmp;
 265   2          }
 266   1          else
 267   1          {
 268   2              return volt;
 269   2          }
 270   1      }
 271          
 272          /// @brief 用于快速切换滤波方式的函数指针数组
 273          uchar (*filtFuns[11])() =
 274              {
 275                  avgFilt,
 276                  slideavgFilt,
 277                  speedFilt,
 278                  amplimtFilt,
 279                  midFilt,
 280                  midavgFilt,
 281                  limtvgFilt,
 282                  onlastFilt,
 283                  weislidFlit,
 284                  debFilt,
 285                  debavgFilt,
 286          };


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    934    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
